<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 Animated Background</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas */
        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0; /* Ensure it stays behind the main content if any is added later */
        }
        /* Ensure the body covers the entire viewport */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars due to fixed canvas */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'deep-dark': '#0a0a0a', // Almost black
                        'tech-accent': '#34d399', // Emerald 400 (Electric Green/Teal)
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-deep-dark font-sans antialiased">

    <!-- The Canvas for the Background Animation is now the only visible element -->
    <canvas id="particleCanvas"></canvas>

    <!-- The original content layer div is removed. -->

    <script>
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration for the animation (Updated for Tech Accent)
        const NUM_PARTICLES = 100; // Density
        const LINE_DISTANCE = 150; // Max distance for connecting lines
        const PARTICLE_SPEED = 0.4;
        const PARTICLE_RADIUS = 1.5;
        // Use the new Emerald/Teal color for the animation
        const PARTICLE_COLOR = 'rgba(52, 211, 153, 0.7)'; // Tech Accent (Emerald 400)
        const LINE_COLOR = 'rgba(52, 211, 153, 0.05)'; // Very subtle transparent line

        let width, height;
        let particles = [];

        // Function to resize the canvas to fill the entire viewport
        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // Particle constructor function
        function Particle(x, y) {
            this.x = x;
            this.y = y;
            // Set a random initial velocity (very slow)
            this.vx = (Math.random() - 0.5) * PARTICLE_SPEED;
            this.vy = (Math.random() - 0.5) * PARTICLE_SPEED;
        }

        // Initialize particles
        function initParticles() {
            particles = [];
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                particles.push(new Particle(x, y));
            }
        }

        // Update particle positions and handle bouncing off edges
        function updateParticles() {
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const p = particles[i];

                // Update position
                p.x += p.vx;
                p.y += p.vy;

                // Bounce off edges (subtle physics)
                if (p.x < 0 || p.x > width) p.vx *= -1;
                if (p.y < 0 || p.y > height) p.vy *= -1;

                // Dampening for a slow, floating effect
                p.vx *= 0.999;
                p.vy *= 0.999;

                // Add slight random re-acceleration to keep it moving gently
                p.vx += (Math.random() - 0.5) * 0.01;
                p.vy += (Math.random() - 0.5) * 0.01;
            }
        }

        // Draw particles and lines
        function draw() {
            // Clear the entire canvas with the background color with a slight opacity for a smooth trail
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)'; // Deep dark background with a slight opacity
            ctx.fillRect(0, 0, width, height);
            
            // 1. Draw connecting lines
            for (let i = 0; i < NUM_PARTICLES; i++) {
                for (let j = i + 1; j < NUM_PARTICLES; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];

                    // Calculate distance squared (saves a sqrt operation)
                    const distSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
                    const lineDistSq = LINE_DISTANCE ** 2;

                    if (distSq < lineDistSq) {
                        // Calculate line opacity based on distance (closer = less transparent)
                        const opacity = 1 - (distSq / lineDistSq);
                        // The line color uses the LINE_COLOR base, adjusting opacity
                        ctx.strokeStyle = LINE_COLOR.replace('0.05', (0.05 * opacity).toFixed(3));
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // 2. Draw particles
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const p = particles[i];
                ctx.fillStyle = PARTICLE_COLOR;
                ctx.beginPath();
                ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // The main animation loop
        function animate() {
            updateParticles();
            draw();
            requestAnimationFrame(animate);
        }

        // Initial setup
        window.addEventListener('load', () => {
            resizeCanvas();
            initParticles();
            animate();
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

    </script>
</body>
</html>